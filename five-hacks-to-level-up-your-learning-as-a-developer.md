# Five Hacks To Level Up Your Learning As A Developer

## Introduction

At Quick Left, we spend a lot of time thinking about how we learn.

As consultants, we find ourselves in a new code base, or coming to terms with a new business domain, on a regular basis. [Getting ramped up on code](https://quickleft.com/blog/ramping-up-developers-on-code/) is the name of the game, so effective learning is an essential skill for us.

Even if you're not a consultant, knowing the lay of the land when it comes to the latest and greatest technologies is essential if you're a developer. Programmers spend a lot of cycles tinkering with "the new hotness". For every framework or language that does eventually see some level of success, many others fail. Because of this, we inevitably invest some time learning things we'll never use. It's important to be efficient in our learning, to minimize wasted time and effort.

Other programmers ask me about some of the strategies I use in my own learning. Because I used to be a teacher, I've spent a fair amount of time thinking about how people learn. In this post, we'll talk about how to examine your learning process so that you can learn more effectively as a programmer.



## 1. Know Your Learning Style

One of the easiest things you can do to understand how you learn best is to find out your learning style.

You may have heard of the three learning modalities proposed by [Walter Burke Barbe et al](https://en.wikipedia.org/wiki/Learning_styles): Visual, Auditory, and Kinesthetic. Just about everyone can learn from all of these approaches, but it's helpful to get an idea of how attuned you are to each of them. You can find out in twn minutes by taking an [online quiz](http://www.educationplanner.org/students/self-assessments/learning-styles.shtml). Knowing your basic breakdown will benefit you in countless learning situations, code-related or not.

Here are some ways that work well for learning technology using each of the modalities:

Visual learners can benefit from scanning project structures, sketching ERD and other architectural diagrams, watching screencasts, and reading through source code.

Auditory learners might learn well from listening to podcasts, conference talks on YouTube, and speaking documentation aloud.

Kinesthetic learners will feel attuned in their learning by working through tutorials, experimenting with demo projects, working with hardware, and mapping out how components interact by creating physical models.

Keep in mind that you might benefit from a mixture of approaches. Looking at things from a variety of approaches can give you a more in-depth understanding of what is going on.

## 2. Consider Finding A Mentor

This might be obvious, but one of the easiest ways to level up is by working with someone who already knows whatever you're trying to learn. If you happen to be extroverted, it may work better for you than studying alone could ever do. Even if you're not, [working with a mentor](https://quickleft.com/blog/mentoring-in-programming-what-why-and-how-series/) can be a great idea.

There are several strategies a mentor can take to help you learn. They can suggest thought exercises or prompts for you to work on, review your code, and explain how higher level concepts fit together.

But perhaps the most valuable thing a mentor can do is to [pair program](https://quickleft.com/blog/to-pair-or-pair-that-is-the-question/) with you. Being present while an experienced programmer thinks through and solves a problem in a new language or framework can be very illuminating. If you can think of anyone who knows about what you want to learn, consider asking them to work with you. Even a one-hour session can take you leaps and bounds beyond your current capabilities.

## 3. Time Boxing

When I was a bootcamp student, my instructor [Jeff Casimir](https://twitter.com/j3) taught on a [Pomodoro](http://pomodorotechnique.com/) schedule, and encouraged us to take the same approach in our project work and individual learning. We would focus on a single aspect of web development for 25 minutes while avoiding distractions completely, then take a 5 minute break where we would completely switch context.

By the end of the program, I was Pomodoroing my way through my entire 14 hour day, only turning off the times for meals and an afternoon walk. Of course, this was an extreme application of timeboxing I was using to cram as much knowledge and experience into my head as I could. But I still turn to [Menubar Countdown](http://capablehands.net/menubarcountdown) whenever I want maximum efficiency.

If you haven't tried timeboxing, I'd definitely recommend trying it for a couple of hours one day. I've found it most effective when you're strict about removing distractions like company chat, text messaging, and social media. It also works best when you set an intention at the beginning of each work session. When it comes to learning, it can keep you focused on finding out what you want to know without getting dragged down rabbit-holes or spending more time than you intended on something.

## 4. Reading Strategies

Education research has produced a deep wealth of strategies for learning over the past 30 years. If there's one thing that has been studied and thought about the most, it's reading. Being a strong reader is a crucial skill for effective learning. Reading code is no exception.

One of the first things I learned when I first entered the industry was the importance of reading through source code. When you're relying on packages and libraries for key functionality in your application, sometimes it's the only way you can track down puzzling bugs. At the same time, reading through source can be a great way to get to know the idioms at use in your community. I personally like to follow what's going on with [Ruby on Rails](https://groups.google.com/forum/#!forum/rubyonrails-core), since the community is so active and always working on new things.

There are a couple of reading strategies that you might find helpful when you're trying grok a new technology.

The first is called [RAP](https://teal.ed.gov/sites/default/files/Fact-Sheets/10_TEAL_Self_Reg_Strat_Dev_0.pdf), or Read, Ask, Paraphrase. In this approach, you make an effort to monitor your understanding as you go along. The procedure is fairly simple: begin by reading a unit of text (a paragraph, for example). When you're done, ask yourself about what you've read. What is the topic? What are the key points? What are the most important details? What's the author's attitude toward the topic? Finally, try to summarize what you've read to yourself. If you're struggling, that's a flag that you haven't fully digested what you've read. It can also be helpful to perform this process at a higher level as well, paraphrasing a complete article or module of source code once you've read it.

The other strategy you might like to try is to approach the questions you ask yourself from a higher level of thinking. There's a model of thinking called [Bloom's Taxonomy](https://teal.ed.gov/sites/default/files/Fact-Sheets/12_TEAL_Deeper_Learning_Qs_complete_5_1_0.pdf) that lists levels of questioning according to the level of cognitive demand. The most recent version of Bloom's Taxonomy begins with remembering as the easiest level, then progressed through understanding, applying, analyzing, evaluating, finally coming to creating as the most demading level.

The idea with this model is that as you engage in higher levels of thinking, you necessarily employ the levels below it as well. That means that if you are _creating_ something, you'll also need to engage remembering, understanding, analyzing, and evaluating. Although it's suggested that you approach the material from a variety of levels, a study conducted in 1981 showed that using more higher-level questioning leads to better factual recall and application of thinking skills.

Here are some specific ways you can apply higher levels of thinking when learning tech. When you're trying to understand _why_ something is done a certain way, ask for evidence. How do you know that a linked list is more performant than an array? Look at a benchmark! You should also ask for clarification. Find out how the details work. Another idea is to make connections between what you're learning and what you already know. For example: "I know how to use Rake in Ruby to run builds and utility tasks. How do I solve that problem in JavaScript?" Ask hypothetical questions. If you learn how to use a certain method, ask yourself: "what would happen if I passed it nil instead?" The answers to thought experiments like these can really illuminate the inner workings of an API. Similarly, you can think about cause and effect. "What is likely to be the effect of foo?" Finally, engage in some self-reflection after reading by summarizing what you've learned. Ask yourself for one or two key points at the end of each learning session. Say them out loud, or [write a blog post](https://quickleft.com/blog/write-technical-blog-post-part-1/) about them. Also ask yourself what still feels unresolved - what do you _not_ understand? That can give you a good jumping-off point in what to look at during your next session.

## 5. Charts and Graphs

In addition to reading strategies, education research has produced a large number learning tools with a proven track record of success. You may have used some of these when you were in school and forgotten about them. Rediscovering them as an adult can prove beneficial to your learning. Why not try experimenting with them?

### KWL Chart

The [KWL Chart](https://teal.ed.gov/sites/default/files/Fact-Sheets/12_TEAL_Deeper_Learning_Qs_complete_5_1_0.pdf) is a great way to guide yourself in prioritizing what you want to learn about. The acronym stands for "Know", "Want to Know", and "Learned".

To use a KWL chart, make three columns on a piece of paper or electronic document, and give them headings of "K", "W", and "L".

When you begin a learning session, choose a topic. Before you read anything about it, brainstorm words, terms, and phrases representing what you already know about the topic, and record these in the "K" column.

Next, ask yourself what you think you'd like to know about the topic and record it in the "W" column. In this step, you are setting your intention for your learning session. You're also giving yourself a map of what things you need to focus on. As you begin doing your research, you can always add more things to the "W" column to investigate later on.

Finally, as you read about your chosen topic, record what you find out in the "L" column. This isn't a place to take extensive notes. Just write down key phrases that will help you remember the broader concepts you learned about.

### Venn diagram

[Venn diagrams](https://en.wikipedia.org/wiki/Venn_diagram) are a widely known way to explore the relationship between two different sets of data. When it comes to learning, they can be really helpful for understanding the distinction between two languages or frameworks.

For example, imagine you are a front-end JavaScript developer with experience in Backbone, and you were trying to learn Angular. You might draw a Venn diagram with Backbone in one circle, and Angular in another. To begin, you could fill in some of the things you know about Backbone in its circle. You might write down "models automatically integrate with a REST API". Then as you read about Angular, you can fill in its circle. You might write "ngModel reflects data between the DOM and scope directive". In the middle, you can record things that they share. For example, "AJAX requests wrapped by internal library with convenience methods that return a promise".

This strategy might seem superfluous at first. Why write it down if you already understand the distinction? But having everything laid out in front of you visually can really help you get a mental map of the relationship between two areas of learning. Also, approaching your research with a mind that's looking for similarities and differences in relation to something you already know can lead you to ask different questions than you might have otherwise.

### Concept Map

Another diagram that might be familiar to you is the [Concept Map](https://en.wikipedia.org/wiki/Concept_map). A concept map is basically a bunch of boxes connected by arrows. You connect the boxes from top to bottom, with the arrows representing causation.

When I first began to study computer programming, I was struck by how similar the evaluation of a program is to the playing of a piece of written music. The "playing" of a program involves the computer interpreting the current line of code, and every time it encounters a variable or method call it hasn't seen yet, it goes and interprets that line before returning to what it was doing.

Following this line of unfolding logic, we begin to discover lines of causation in our programs. Drawing these out in a concept map can be very illuminating. To continue our Angular example, we might draw a concept map that goes something like this:

- User types into input
- ngModel is updated
- form is set dirty and touched
- ngModelController evaluates validity of form
- ngModel's value is set to the value of the input
- $scope.$watch() listeners are triggered
- Etc.

Drawing things out like this so that you can see the bigger picture can really help you wrap your head around what's going on. Once you have that bigger perspective, it's easier to understand bugs as they crop up, and know what to do first when you're trying to build a new feature.

## Conclusion

Being a programmer is tough work. As if solving complex problems and debugging dependency issues weren't enough, we have to stay up on the latest technologies, and continue learning all the time to keep abreast of the pace of technology. Sometimes trying to organize that process can feel like throwing spaghetti at the wall and seeing what sticks. But our time is precious, so we would like to make the most of the it when we sit down to learn.

In this article, we explored educational research on Metacognition - awareness of our own knowledge and learning process. We explored the Planning-Monitoring-Evaluating framework. This approach gives us a way to break down a learning session and ask ourselves self-reflective questions along the way to make sure we're getting the most out of our time.

In a future article, we'll take a look at some more specific strategies that can also be used to level up your metacognitive knowledge and regulation efforts.

Until then, best of luck, and see you on the interwebs!

P.S. Do you have any learning tools you want to share? We looked at education-based strategies here, but I'd love to hear about any programming-specific ideas you might have. Leave us a comment!

